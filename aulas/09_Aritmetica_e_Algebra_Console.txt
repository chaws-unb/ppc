
                      [1mAritmÃ©tica e Ãlgebra[0m


[4mMatemÃ¡tica[24m [4me[24m [4mProgramaÃ§Ã£o[0m

  â†’  A relaÃ§Ã£o entre a matemÃ¡tica e a programaÃ§Ã£o jÃ¡ estÃ¡ bem esâ€
  tabelecida

  â†’ Os primeiros computadores foram construÃ­dos por  matemÃ¡ticos,
  para acelerar seus cÃ¡lculos

  â†’  Pascal  construiu,  em  1645, uma mÃ¡quina de adiÃ§Ã£o mecÃ¢nica
  baseada em engrenagens

  â†’ Pioneiros da computaÃ§Ã£o como Turing  e  von  Newmann  tiveram
  grandes  resultados  na matemÃ¡tica, tÃ£o ou mais expressivos que
  suas contribuiÃ§Ãµes na computaÃ§Ã£o

[4mAritmÃ©tica[24m [4mde[24m [4mmÃ¡quina[0m

  â†’ Toda linguagem de programaÃ§Ã£o possui um tipo  inteiro  bÃ¡sico
  com suporte Ã s quatro operaÃ§Ãµes elementares: adiÃ§Ã£o, subtraÃ§Ã£o,
  multiplicaÃ§Ã£o e divisÃ£o

  â†’ Como estas operaÃ§Ãµes geralmente mapeadas em hardware  (com  a
  Ãºnica  exceÃ§Ã£o  comum  sendo a divisÃ£o), o intervalo de nÃºmeros
  representÃ¡veis em uma variÃ¡vel inteira depende  da  arquitetura
  onde o cÃ³digo rodarÃ¡

  â†’  Numa arquitetura de 32â€bits, o intervalo serÃ¡ de + ou â€ 2 **
  31, isto Ã©, 2.147.483.648

  â†’ Ou seja, neste cenÃ¡rio Ã© seguro  contar  atÃ©  um  bilhÃ£o  com
  variÃ¡veis inteiras

  â†’ Em arquiteturas de 64â€bits, o intervalo sobe para + ou â€ 2 **
  63, o que dÃ¡ + ou â€ 9.223.372.036.854.775.808, isto Ã©,  nÃºmeros
  com atÃ© 19 dÃ­gitos (acima dos trilhÃµes)

  â†’ Estas representaÃ§Ãµes de 4 ou 8 bytes por inteiro pode ser inâ€
  eficiente, no quesito espaÃ§o em memÃ³ria,  quando  Ã©  necessÃ¡rio
  armazenar  vÃ¡rios nÃºmeros com ordem significativamente menor do
  que os limites mÃ¡ximos (por exemplo, 256 tons de cinza em  imaâ€
  gens)

  â†’  Nestes  casos,  Ã©  Ãºtil utilizar os tipos short ou char, que
  ocupam menos memÃ³ria e,  consequentemente,  tem  intervalos  de
  valores possÃ­veis reduzidos

  â†’  Os  nÃºmeros  positivos  sÃ£o representados em memÃ³ria por sua
  forma binÃ¡ria

  â†’ Os nÃºmero negativos sÃ£o representados em complementos de 2, o
  que  permite  realizar  as  operaÃ§Ãµes em hardware de forma mais
  eficiente

  â†’ JÃ¡ a representaÃ§Ã£o de nÃºmeros em ponto flutuante Ã© mais  comâ€
  plexa,  envolvendo a mantissa e o expoente, em relaÃ§Ã£o a base 2
  (a x 2 ^ c)

  â†’ Como os bits sÃ£o divididos entre a e c, os tipos float e douâ€
  ble nÃ£o sÃ£o adequados para grandes contagens

[4mBibliotecas[24m [4mpara[24m [4mInteiros[0m

  â†’ Em C, a biblioteca stdlib.h oferece funÃ§Ãµes para o cÃ¡lculo do
  valor absoluto e para geraÃ§Ã£o de nÃºmeros randÃ´micos

  â†’ A  biblioteca  math.h  contÃ©m  arredondamentos,  trucamentos,
  raizes e exponenciais

[4mInteiros[24m [4mde[24m [4mAlta[24m [4mPrecisÃ£o[0m

  â†’ Para representar inteiros de alta precisÃ£o (com grande nÃºmero
  de dÃ­gitos), Ã© necessÃ¡rio armazenar os dÃ­gitos sequencialmente

  â†’ Uma primeira forma Ã© o array de dÃ­gitos, que Ã© a mais simples
  das  representaÃ§Ãµes.  O primeiro elemento do array representa o
  dÃ­gito menos significativo. Manter o nÃºmero de dÃ­gitos pode auâ€
  mentar a eficiÃªncia de algumas operaÃ§Ãµes

  â†’  Outra forma Ã© a lista encadeada de dÃ­gitos. Embora menos coâ€
  mum, pode ser  necessÃ¡ria  em  caso  de  nÃºmero  excessivamente
  grandes,  e nÃ£o seja possÃ­vel encontrar espaÃ§o em memÃ³ria alinâ€
  hado o suficiente para a representaÃ§Ã£o em arrays

    Â· CÃ³digo: bignum.c (DefiniÃ§Ã£o da estrutura bignum)

  â†’ Embora o cÃ³digo esteja em base 10,  bases  maiores  sÃ£o  mais
  eficientes em termos de uso de memÃ³ria

  â†’  Este cÃ³digo tambÃ©m utiliza um limite subjacente, e nÃ£o veriâ€
  fica a possibilidade de overflow

[4mAritmÃ©tica[24m [4mde[24m [4mAlta[24m [4mPrecisÃ£o[0m

  â†’ A adiÃ§Ã£o Ã© feita da esquerda para a direita, do dÃ­gito  menos
  significativo  para  o  mais  significativo, somando ao prÃ³ximo
  dÃ­gito o valor do carry (vai um) quando necessÃ¡rio

  â†’ A soma com nÃºmeros negativos deve ser tratada  como  um  caso
  especial, atravÃ©s de uma funÃ§Ã£o de subtraÃ§Ã£o quando as parcelas
  tem sinais distintos

    Â· CÃ³digo: bignum.c (add_bignum() e zero_justify())

  â†’ Como a substituiÃ§Ã£o envolve o emprÃ©stimo, Ã© necessÃ¡rio que  a
  primeira parcela seja a de maior mÃ³dulo

    Â· CÃ³digo: bignum.c (subtract_bignum())

  â†’  A  comparaÃ§Ã£o de dois nÃºmeros deve ser feita a partir do dos
  dÃ­gitos mais significativos, levando primeiramente  em  considâ€
  eraÃ§Ã£o  os  sinais  dos  nÃºmeros:  se  ambos forem negativos, o
  nÃºmero de maior mÃ³dulo Ã© o menor dos dois

    Â· CÃ³digo: bignum.c (compare_bignum())

  â†’ Embora a multiplicaÃ§Ã£o possa ser interpretada como somas  suâ€
  cessivas,  a implementaÃ§Ã£o sob esta Ã³tica Ã© potencialmente ineâ€
  ficiente

  â†’ O algoritmo utilizado na escola pode ser utilizado como  base
  para a implementaÃ§Ã£o da multiplicaÃ§Ã£o

    Â· CÃ³digo: bignum.c (multiply_bignum())

  â†’  O deslocamento de um bit para a direita equivale a multipliâ€
  caÃ§Ã£o por 10

    Â· CÃ³digo: bignum.c (digit_shift())

  â†’ TambÃ©m a divisÃ£o pode ser implementada de acordo com o  algoâ€
  ritmo aprendido na escola

    Â· CÃ³digo: bignum.c (divide_shift())

  â†’  A rotina da divisÃ£o descarta o resto, que pode ser computado
  atravÃ©s da expressÃ£o a â€ b*(a / b), ou utilizando  tÃ©cnicas  de
  Teoria dos NÃºmeros, que serÃ£o vistas adiante

  â†’ Quando um ou ambos termos sÃ£o negativos, os sinais do resto e
  do quociente nÃ£o sÃ£o definidos claramente, e  podem  variar  de
  acordo com a implementaÃ§Ã£o utilizada

  â†’ A exponenciaÃ§Ã£o tambÃ©m Ã© vista como a multiplicaÃ§Ã£o repetida.
  Contudo, a implementaÃ§Ã£o deve levar em conta de que a^n = (a  ^
  n/2)  *  (a ^ n/2) * (a ^ n % 2), de modo que serÃ£o necessÃ¡rias
  cerca de log n operaÃ§Ãµes

[4mBases[24m [4mNumÃ©ricas[24m [4me[24m [4mConversÃµes[0m

  â†’ A representaÃ§Ã£o de um nÃºmero depende da base utilizada, sendo
  as  mais  comuns  a  binÃ¡ria  (base 2), octal (base 8), decimal
  (base 10) e hexadecimal (base 16)

  â†’ A base binÃ¡ria utiliza dois dÃ­gitos: 0 e 1, e Ã© a  base  utiâ€
  lizada nos computadores, uma vez que mapeia naturalmente os esâ€
  tados ligado/desligado

  â†’ A base octal fornece uma maneira rÃ¡pida e concisa  de  repreâ€
  sentar  nÃºmeros binÃ¡rios, em grupos de trÃªs em trÃªs. Os dÃ­gitos
  utilizados variam de 0 a 7

  â†’ A base decimal Ã© a mais utilizada no cotidiano, e foi adotada
  historicamente,  sendo  preferida entre bases de 20 ou 60 dÃ­giâ€
  tos, utilizados por povos antigos  em  diferentes  momentos  da
  histÃ³ria

  â†’  A  base  hexadecimal utiliza os dez dÃ­gitos decimais mais as
  seis primeiras letras do alfabeto. Ã‰ uma forma ainda mais  comâ€
  pacta  de representaÃ§Ã£o de bits, representando um byte com apeâ€
  nas dois sÃ­mbolos

  â†’ Ã‰ possÃ­vel utilizar outras bases, uma vez providos os  sÃ­mboâ€
  los para todos os dÃ­gitos. Por exemplo, utilizando os dez dÃ­giâ€
  tos e as 26 letras do alfabeto Ã© possÃ­vel utilizar a base 36

  â†’ Em certificados digitais, Ã© utilizada a base 64, que  utiliza
  dÃ­gitos,  letras  maiÃºsculas e minÃºsculas, e os sÃ­mbolos + e /,
  alÃ©m do sÃ­mbolo = ou == para padding

  â†’ HÃ¡ dois tipos de algoritmos para conversÃ£o entre bases

  â†’ O primeiro age da esquerda para a direita,  determinando,  em
  cada  etapa, o dÃ­gito mais significativo, pois (d_l + 1)b^k > x
  >= d_lb^k, onde 1 <= d_l <= b â€ 1

  â†’ Neste algoritmo, Ã© preciso ser capaz de comparar a  magnitude
  de  nÃºmeros de diferentes bases, e equivale ao algoritmo da diâ€
  visÃ£o

  â†’ O outro algoritmo consiste em determinar o dÃ­gito menos  sigâ€
  nificativo  em  cada  etapa, utilizando os algoritmos de resto.
  Este algoritmo Ã© mais apropriado  para  trabalhar  com  grandes
  nÃºmeros

    Â· CÃ³digo: bignum.c (int_to_bignum())

[4mNÃºmeros[24m [4mreais[0m

  â†’ O tratamento de nÃºmeros reais, em computador, Ã© limitado pelo
  fato de que o ponto flutuante tem precisÃ£o limitada,  de  modos
  que os nÃºmeros nÃ£o sÃ£o os reais de fato

  â†’  Na  matemÃ¡tica,  a continuidade dos reais garante que sempre
  existe um nÃºmero c entre a e b, o  que  nÃ£o  Ã©  necessariamente
  verdadeiro nos computadores

  â†’  Muitos  algoritmos sÃ£o baseados no cÃ¡lculo exato, e os erros
  de precisÃ£o do computador podem gerar resultados errados

  â†’ Por exemplo, a associatividade da adiÃ§Ã£o (a + b) + c = a + (b
  + c) nÃ£o Ã© sempre verdadeira devido a erros de arredondamento

  â†’  Os outros conjuntos numÃ©ricos tambÃ©m sÃ£o importantes na comâ€
  putaÃ§Ã£o, como os nÃºmeros inteiros, jÃ¡ citados

  â†’ Os nÃºmeros racionais sÃ£o formados por quocientes de  inteiros
  (com  denominador  nÃ£o nulo), e contÃ©m os inteiros como subconâ€
  junto. Geralmente sÃ£o entendido como as fraÃ§Ãµes

  â†’ Os nÃºmeros irracionais sÃ£o nÃºmeros que nÃ£o podem  ser  repreâ€
  sentados  como fraÃ§Ãµes, como o pi, o e e raiz de dois. A repreâ€
  sentaÃ§Ã£o em computador destes nÃºmeros sÃ³  pode  ser  aproximada
  atÃ© uma determinada ordem, via sÃ©ries de Taylor

  â†’  A  representaÃ§Ã£o interna dos nÃºmeros reais depende de compiâ€
  lador para compilador, de linguagem a linguagem, e de  computaâ€
  dor para computador

  â†’   HÃ¡  uma  padrÃ£o  IEEE para tal representaÃ§Ã£o, que vem sendo
  adotada por cada vez mais fabricantes, mas ainda hÃ¡ muitas outâ€
  ras soluÃ§Ãµes no mercado

  â†’  A  representaÃ§Ã£o  Ã© baseada na notaÃ§Ã£o cientÃ­fica ax2^c, com
  uma mantissa e um expoente c

  â†’ Se os expoentes dos nÃºmeros a serem operados forem muito disâ€
  tintos,  Ã©  possÃ­vel  que surjam erros de underflow e overflow,
  pois nÃ£o haverÃ¡ espaÃ§o suficiente na mantissa para  acomodar  a
  resposta

  â†’  Estes  problemas sÃ£o ainda mais evidentes quando se trata de
  igualdades: sujeiras na mantissa podem fazer com que expressÃµes
  claramente iguais sejam interpretadas como distintas

    Â· CÃ³digo: bug.c

  â†’  A  comparaÃ§Ã£o  entre nÃºmeros reais deve ser feita utilizando
  uma margem de erro epsilon aceitÃ¡vel

  â†’ Truncar um nÃºmero significa descartar a parte real, resultanâ€
  do em um inteiro. A funÃ§Ã£o floor() da biblioteca math.h realiza
  o truncamento

  â†’ Arredondar significar aproximar atÃ© uma certa casa, de acordo
  com  as regras de arredondamento. Para arredondar X atÃ© k dÃ­giâ€
  tos,  utilize  a  expressÃ£o  round(X,  k)   =   floor(10^kX   +
  (1/2))/10^k

  â†’  A  formataÃ§Ã£o de output das linguagens de programaÃ§Ã£o variam
  no que diz respeito ao arredondamento ou truncamento dos resulâ€
  tados

[4mFraÃ§Ãµes[0m

  â†’  A  melhor representaÃ§Ã£o de uma fraÃ§Ã£o exata x/y Ã© atravÃ©s de
  um par ordenado (x, y), onde x Ã© o numerador e y o denominador

  â†’ As operaÃ§Ãµes bÃ¡sicas com fraÃ§Ãµes sÃ£o facilmente implementadas
  em computador, com c = (x1, y1) e d = (x2, y2)

  â†’  A  adiÃ§Ã£o depende de um mÃºltiplo comum dos denominadores, de
  modo que c + d = (x1y2 + x2y1, y1y2)

  â†’ A subtraÃ§Ã£o Ã© uma adiÃ§Ã£o: c â€ d = c + (â€d)

  â†’ A multiplicaÃ§Ã£o Ã© a soma repetida, e no  caso  de  fraÃ§Ãµes  Ã©
  simplemente cd = (x1x2, y1y2)

  â†’  A  divisÃ£o  Ã© a multiplicaÃ§Ã£o pelo recÃ­proco, isto Ã© c / d =
  (x1y2, x2y1)

  â†’ Para evitar  erros  de  overflow,  Ã©  importante  reduzir  as
  fraÃ§Ãµes resultantes

  â†’ Isto Ã© feito atravÃ©s da divisÃ£o do numerador e do denominador
  pelo MDC entre eles

  â†’ Existem algoritmos eficientes para computar o  gcd  entre  os
  nÃºmeros, e serÃ£o apresentados adiante

[4mRepresentaÃ§Ã£o[24m [4mdecimal[0m

  â†’ Consiste em um caso especial dos nÃºmeros racionais

  â†’  Ã‰  necessÃ¡rio encontrar a fraÃ§Ã£o geratriz do nÃºmero decimal,
  isto Ã©, a fraÃ§Ã£o cuja divisÃ£o geral tal nÃºmero

  â†’ Por exemplo, 3,1415 = (3/1) + (1415/10000) = 6283/20000

  â†’ Caso  o  nÃºmero  seja  uma  dÃ­zima  periÃ³dica,  Ã©  necessÃ¡rio
  primeiramente identificar o perÃ­odo R e seu tamamho l

  â†’  Em  seguida, basta observar que 10^l(a/b) â€ (a/b) = R, o que
  nos dÃ¡ (a/b) = R/(10^l â€ 1)

  â†’ Por exemplo, (a/b) = 0.0123123 tem R = 12.3 e l =  3,  o  que
  nos dÃ¡ (a/b) = 123/9990



















