
                            [1mOrdenaÃ§Ã£o[0m


[4mEstudo[24m [4mdos[24m [4malgoritmos[24m [4mde[24m [4mordenaÃ§Ã£o[0m

  â†’  A ordenaÃ§Ã£o Ã© considerada um dos algoritmos mais importantes
  da ciÃªncia da computaÃ§Ã£o

  â†’ O estudo dos algoritmos de ordenaÃ§Ã£o Ã© importante devido dois
  motivos:

    Â·  Muitos dos problemas prÃ¡ticos envolvem a ordenaÃ§Ã£o de eleâ€
    mentos ou podem ser resolvidos de forma mais eficiente se  os
    dados estiverem ordenados

    Â·  Os  diferentes  algoritmos  de  ordenaÃ§Ã£o  sÃ£o baseados em
    ideias e conceitos importantes na formaÃ§Ã£o de um estudante  e
    profissional da Ã¡rea de computaÃ§Ã£o

[4mAplicaÃ§Ãµes[24m [4mda[24m [4mordenaÃ§Ã£o[0m

  â†’  Teste de unicidade: verificar se os elementos de um determiâ€
  nado conjunto sÃ£o Ãºnicos ou nÃ£o. Basta ordenar os  elementos  e
  depois, em uma travessia, observar se dois elementos adjacentes
  sÃ£o ou nÃ£o iguais

  â†’ RemoÃ§Ã£o de elementos repetidos. Novamente a ordenaÃ§Ã£o dos elâ€
  ementos  facilita  a  tarefa: basta manter o registro do Ãºltimo
  elemento verificado e continuar a travessia elemento a  elemenâ€
  to.  Assim que encontrar um elemento distinto do marcado, deveâ€
  se copiar o elemento encontrado para a posiÃ§Ã£o seguinte Ã   marâ€
  cada e incrementar o marcador

  â†’  Prioridades.  A ideia bÃ¡sica das filas com prioridades Ã© que
  os elementos estejam ordenados de acordo com os critÃ©rios estaâ€
  belecidos

  â†’ CÃ¡lculo da mediana. A mediana Ã© uma medida estatÃ­stica que se
  refere ao termo da posiÃ§Ã£o central, quando as medidas estÃ£o deâ€
  vidamente  ordenadas (ou a mÃ©dia dos elementos centrais, quando
  a quantidade de medidas Ã© par)

  â†’ ReconstruÃ§Ã£o de uma sequÃªncia de elementos. Para manter a seâ€
  quÃªncia  original  de  um conjunto de dados, basta adicionar um
  Ã­ndice que registre a posiÃ§Ã£o do elemento, de forma que  a  seâ€
  quÃªncia original pode se reconstruÃ­da com uma ordenaÃ§Ã£o baseada
  neste Ã­ndice

  â†’ InterseÃ§Ã£o e uniÃ£o de conjuntos. Se ambos conjuntos estÃ£o orâ€
  denados,  a  uniÃ£o  pode ser determinada iterando entre os dois
  conjuntos e escolhendo o menor dentre os  dois  elementos  comâ€
  parados  sucessivamente.  A  interseÃ§Ã£o  pode ser encontrada de
  forma semelhante

  â†’ Escontrar uma soluÃ§Ã£o especÃ­fica. EquaÃ§Ãµes do tipo x + y = z,
  com  inteiros,  podem ter suas soluÃ§Ãµes determinadas atravÃ©s da
  ordenaÃ§Ã£o dos valores possÃ­veis e um laÃ§o onde o Ã­ndice  i  auâ€
  menta enquando o Ã­ndice S[j] = z â€ S[i] diminui

  â†’ Busca eficiente. Vetores ordenados formam a base para a busca
  binÃ¡ria

[4mFunÃ§Ãµes[24m [4mde[24m [4mordenaÃ§Ã£o[24m [4mem[24m [4mC[24m [4me[24m [4mC++[0m

  â†’ A biblioteca â€™stdlib.hâ€™ de C contÃ©m a  funÃ§Ã£o  qsort(),  cuja
  assinatura Ã©
    Â· void qsort(void *base, size_t nel, size_t width, int (*comâ€
    pare)(const void *, const void *)

  â†’ O parÃ¢metro base aponta para o vetor a ser ordenado

  â†’ O parÃ¢metro nel determina o nÃºmero de elementos a serem ordeâ€
  nados,  enquanto  o parÃ¢metro width define o tamanho, em bytes,
  de cada elemento do vetor (o qual pode ser determinado  atravÃ©s
  do operador sizeof)

  â†’  Por fim, a ordenaÃ§Ã£o Ã© determinada pela funÃ§Ã£o de comparaÃ§Ã£o
  cujo ponteiro Ã© o quarto parÃ¢metro. Ele recebe dois  argumentos
  do  tipo de base, e deve retornar um nÃºmero maior do que, igual
  a ou menor do que zero caso o primeiro  argumento  seja  maior,
  igual ou menor do que o segundo

    Â· CÃ³digo: intcompare.h
    Â· CÃ³digo: intcompare.c
    Â· CÃ³digo: megasena.c

  â†’  A  biblioteca  â€™stdlib.hâ€™ tambÃ©m contÃ©m uma implementaÃ§Ã£o da
  busca binÃ¡ria com a funÃ§Ã£o bsearch(), cuja assinatura Ã© idÃªntiâ€
  ca  a  da  qsort(), exceto pelo primeiro parÃ¢metro key, que Ã© o
  valor a ser encontrado:
    Â· bsearch(const void *key,  const  void  *base,  size_t  nel,
    size_t width, int compare(const void *, const void *))

  â†’  Em  C++,  a  STL  (Standard Template Library) provÃª a funÃ§Ã£o
  sort(), na biblioteca â€™algorithmsâ€™, cuja assinatura Ã©
    Â· sort(RandomAcessIterator bg, RandomAcessIterator end);
    Â· sort(RandomAcessIterator bg, RandomAcessIterator end,  Comâ€
    pare comp);

  â†’  Esta  funÃ§Ã£o utiliza o operador de comparaÃ§Ã£o <, seja sobreâ€
  scrito ou a versÃ£o default para o tipo de dado do vetor

  â†’ O parÃ¢metro comp deve ser uma funÃ§Ã£o ou uma classe ou  estruâ€
  tura  que  tenha  uma funÃ§Ã£o ou operador com assinatura equivaâ€
  lente a assinatura abaixo:
    Â· bool cmp(const Type1& a, const Type2& b);

  â†’  O  retorno  deve  ser  verdadeiro  (true)  caso  o  primeiro
  parÃ¢metro seja menor do que o segundo

  â†’  A STL tambÃ©m provÃª a funÃ§Ã£o stable_sort(), cuja assinatura Ã©
  idÃªntica a da sort(), mas ela mantem a ordem relativa dos  terâ€
  mos quando ambos sÃ£o iguais
    Â· CÃ³digo: megasena.cpp

  â†’ Outras funÃ§Ãµes associadas a ordenaÃ§Ã£o disponÃ­veis na STL sÃ£o:
  set_union(),  set_intersection(),  set_difference(),   nth_eleâ€
  ment(), unique()













