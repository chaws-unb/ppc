
                        [1mTeoria dos Grafos[0m


[4mTeoria[24m [4mdos[24m [4mGrafos[0m

  ‚Üí Estuda as propriedades das estruturas dos grafos

  ‚Üí  Ela define uma linguagem para a descri√ß√£o e entendimento dos
  grafos

  ‚Üí Muitos problemas s√£o resolvidos atrav√©s da  identifica√ß√£o  da
  no√ß√£o  da Teoria dos Grafos subjacente e a aplica√ß√£o de algori‚Äê
  mos cl√°ssicos

[4mPropriedades[24m [4mdo[24m [4mGrau[0m

  ‚Üí Uma grafo √© composto de v√©rtices e arestas

  ‚Üí O grau de um v√©rtice diz respeito ao n√∫mero  de  arestas  que
  est√£o ligadas a ele

  ‚Üí A primeira propriedade relacionada ao grau dos v√©rtices de um
  grafo √© que, em um grafo n√£o‚Äêdirecionado, a soma de todos estes
  graus √© igual ao dobro do n√∫mero de v√©rtices

  ‚Üí  Uma  consequ√™ncia  direta  destas propriedade √© que um grafo
  n√£o‚Äêdirecionado possui um n√∫mero par de v√©rtices com grau √≠mpar

  ‚Üí J√° nos grafos direcionados, a soma dos graus de  chegada  dos
  v√©rtices deve ser igual ao grau de sa√≠da

  ‚Üí √Årvores s√£o grafos n√£o‚Äêdirecionados e ac√≠clicos

  ‚Üí Em uma √°rvoes, folha √© um v√©rtice de grau 1

  ‚Üí  Uma  √°rvore  com n v√©rtices possui n ‚Äê 1 arestas: em √°rvores
  n√£o triviais (n > 2), h√° sempre, no m√≠nimo, 2 folhas

  ‚Üí √Årvores enraizadas s√£o grafos direcionados onde todos os n√≥s,
  exceto a raiz, tem grau de chegada igual a 1. As folhas em grau
  de sa√≠da 0

  ‚Üí √Årvores bin√°rias s√£o √°rvores enraizadas  cujos  v√©rtices  tem
  grau de sa√≠da ou zero ou 2

  ‚Üí Ao menos metade dos v√©rtices de uma √°rvore bin√°ria s√£o folhas

  ‚Üí  A √°rvore de espalhamento de um grafo G = (V, E) √© um subcon‚Äê
  junto E‚Äô de E tal que E‚Äô √© uma √°rvore em V

  ‚Üí Todo grafo conectado tem uma √°rvore de espalhamento

  ‚Üí Pode‚Äêse construir uma  √°rvore  de  espalhamento  atrav√©s  das
  rela√ß√µes de parentesco das buscas por extens√£o ou profundidade

  ‚Üí  A √°rvore de espalhamento m√≠nima √© uma importante propriedade
  dos grafos ponderados

[4mConectividade[0m

  ‚Üí Um grafo √© conectado se existe um caminho n√£o‚Äêdirecionado en‚Äê
  tre cada par de v√©rtices

  ‚Üí  A exist√™ncia de uma √°rvore de espalhamento √© suficiente para
  provar a conectividade

  ‚Üí A conectividade de v√©rtices (ou arestas) √© o menor n√∫mero  de
  v√©rtices  (ou  arestas)  que devem ser removidos para tornar um
  grafo desconectado

  ‚Üí Um √∫nico v√©rtice tal que sua remo√ß√£o torna o grafo  desconec‚Äê
  tado √© denominado v√©rtice de articula√ß√£o

  ‚Üí Qualquer grafo que n√£o possui um v√©rtice de articula√ß√£o √© de‚Äê
  nominado biconectado

  ‚Üí Uma √∫nica aresta cuja remo√ß√£o torna o  grafo  desconectado  √©
  denominada ponte

  ‚Üí Um grafo sem pontes √© denominado biconectado por arestas

  ‚Üí  √â  poss√≠vel  encontrar  v√©rtices de articula√ß√£o e pontes por
  for√ßa bruta: basta remover o v√©rtice/aresta do  grafo  e  veri‚Äê
  ficar se o grafo permanece conectado

  ‚Üí  Componentes  fortemente  conectados  em  grafos direcionados
  dizem respeito √† parti√ß√£o do grafo em conjuntos tais que  exis‚Äê
  tem  caminhos direcionados entre quaisquer pares de v√©rtices de
  um mesmo conjunto

  ‚Üí Tais componentes podem ser identificados atrav√©s  de  traves‚Äê
  sias  de  profundidade,  que  geram  ciclos a partir de um dado
  v√©rtice, e todos os v√©rtices deste ciclo devem estar  no  mesmo
  componente fortemente conectado

[4mCiclos[24m [4mem[24m [4mgrafos[0m

  ‚Üí Todos grafos, que n√£o √°rvores, cont√©m ciclos

  ‚Üí  S√£o  not√°veis  os  ciclos  que  visitam todos os v√©rtices ou
  arestas do grafo

  ‚Üí Um ciclo euleriano visita cada aresta do grafo uma √∫nica  vez
  (um  exemplo  pr√°tico  s√£o as brincadeiras infantis de desenhar
  uma figura sem tirar o l√°pis do papel)

  ‚Üí No sentido mais estrito da palavra, ciclos eulerianos s√£o, de
  fato,  circuitos,  uma vez que podem visitar um v√©rtice mais de
  uma vez

  ‚Üí Todo grafo n√£o direcionado cont√©m um  ciclo  euleriano  se  √©
  conectado e cada v√©rtice tem grau par (pois o circuito deve en‚Äê
  trar e sair de cada v√©rtice que ele encontra)

  ‚Üí Novamente a travessia por  profundidade  pode  ser  utilizado
  para  construir  um ciclo euleriano, identificando um ciclo por
  vez e os unindo ao final atrav√©s dos v√©rtices em comum entre os
  ciclos

  ‚Üí  Se  o grafo for direcionado, a condi√ß√£o para a exist√™ncia de
  ciclos euleriano √© que, para cada v√©rtice, o  grau  de  entrada
  seja igual ao grau de sa√≠da

  ‚Üí  Caminhos  eulerianos  s√£o travessias que visitam cada aresta
  uma √∫nica vez, mas pode n√£o terminar no ponto de sa√≠da

  ‚Üí Todo ciclo euleriano √© um caminho euleriano, mas a  rec√≠proca
  n√£o √© verdadeira

  ‚Üí Um ciclo hamiltoniano √© uma travessia que visita cada v√©rtice
  uma √∫nica vez

  ‚Üí O problema de se determinar um ciclo euleriano em um grafo  G
  =  (V,  E)  pode ser reduzido ao problema de encontrar um ciclo
  hamiltoniano em um grafo G‚Äô = (V‚Äô, E‚Äô) tal que cada v√©rtice  V‚Äô
  representa uma aresta E e as arestas E‚Äô conectam todos os pares
  vizinhos de arestas de G

  ‚Üí N√£o existe um algoritmo eficiente de se determinar  um  ciclo
  hamiltoniano em um grafo

  ‚Üí  Em  um grafo pequeno, a alternativa √© utilizar um backtrack‚Äê
  ing: cada ciclo hamiltoniano pode ser descrito como uma  permu‚Äê
  ta√ß√£o dos v√©rtices

[4mGrafos[24m [4mPlanares[0m

  ‚Üí  Grafos  planares  s√£o aqueles que podem ser desenhados em um
  plano de forma que nenhuma aresta cruze a outra

  ‚Üí Uma importante propriedade de grafos planares √©  a  seguinte:
  se n √© o n√∫mero de v√©rtices, m o n√∫mero de arestas e f o n√∫mero
  de faces, ent√£o a F√≥rmula de Euler diz que n ‚Äê m + f = 2

  ‚Üí √Årvores s√£o grafos planares com apenas uma face

  ‚Üí Existem algoritmos eficientes para testar se um grafo √©  pla‚Äê
  nar ou n√£o, embora sejam deveras complicados

  ‚Üí  A  F√≥rmula de Euler, contudo, pode provar eficientemente que
  um grafo n√£o √© planar: todo grafo  planar  cont√©m,  no  m√°ximo,
  3n‚Äê6 arestas, para n > 2

  ‚Üí  A consequ√™ncia disso √© que cada grafo planar deve cont√©m uma
  v√©rtice de grau, no m√°ximo, igual a 5

[4m√Årvores[24m [4mde[24m [4mespalhamento[24m [4mm√≠nimas[0m

  ‚Üí Uma √°rvore de espalhamento de um grafo G = (V, E) √©  um  sub‚Äê
  conjunto  das arestas E que formam uma √°rvore que conecta todos
  os v√©rtices V

  ‚Üí Para um grafo ponderado, a √°rvore de  espalhamento  m√≠nima  √©
  aquela cuja soma dos pesos das arestas √© o menor poss√≠vel

  ‚Üí  Os  principais algoritmos para se determinar a √°rvore de es‚Äê
  palhamento m√≠nima s√£o do de Kruskal e o de Prim

  ‚Üí  Para tais algoritmos,  √©  necess√°ria  uma  representa√ß√£o  de
  grafo que considere os pesos das arestas

    ¬∑ C√≥digo: edge_weighted_graph.h

  ‚Üí  O algoritmo de Prim monta a √°rvore de espalhamento m√≠nimo em
  est√°gios

  ‚Üí Cada itera√ß√£o do algoritmo adiciona um novo v√©rtice na √°rvore
  de espalhamento

  ‚Üí  Sempre  ser√°  adicionada  a  aresta de menor peso que une um
  v√©rtice da √°rvore a um v√©rtice que n√£o est√° na √°rvore

  ‚Üí A implementa√ß√£o mais simples √© declarar uma vari√°vel booleana
  para cada v√©rtice, indicando se ele j√° est√° na √°rvore ou n√£o, e
  a cada itera√ß√£o buscar, entre as arestas a de  menor  peso  que
  tem exatamente um v√©rtice na √°rvore

  ‚Üí  Outra  possibilidade  √© manter o registro da aresta de menor
  peso de algum v√©rtice da √°rvore para qualquer v√©rtice  que  n√£o
  esteja na √°rvore

  ‚Üí  O  menor  destes ser√° adicionado a cada iter√ß√£o, e os custos
  dos restantes deve ser atualizado

    ¬∑ C√≥digo: prim.c

  ‚Üí A √°rvore de espalhamento m√≠nima ou o custo  total  podem  ser
  obtidos de duas maneiras

  ‚Üí A mais simples √© ampliar este procedimento com impress√µes dos
  v√©rtices, a medida que s√£o inseridos, e acumular  os  pesos  em
  uma vari√°vel que ser√° retornada posteriormente

  ‚Üí Outra forma √© extrair tais informa√ß√µes do vetor de parentesco
  que √© constru√≠do ao longo do algoritmo e do pr√≥prio grafo

  ‚Üí A √°rvore de espalhamento m√°xima pode ser obtida com  o  mesmo
  algoritmo: basta tornar negativo os sinais de todos os pesos

  ‚Üí  A  √°rvore de produtos de espalhamento m√≠nimo pode ser obtida
  novamente com mesmo algoritmo, por√©m utilizando o log  de  cada
  peso

  ‚Üí √Årvores de espalhamento m√≠nimo com gargalo m√≠nimo s√£o √°rvores
  que tem o menor valor m√°ximo poss√≠vel.  As  √°rvores  de  espal‚Äê
  hamento m√≠nimo j√° possuem tal propriedade

  ‚Üí  A  √°rvore de espalhamento m√≠nimo √© √∫nica se todos os m pesos
  s√£o distintos


































