
                       [1mTravessia de Grafos[0m


[4mTipos[24m [4mde[24m [4mtravessia[0m

  â†’ A operaÃ§Ã£o mais bÃ¡sica em grafos Ã© a travessia, que consistem
  em visitar todos os vÃ©rtices e todas  arestas  do  grafos,  uma
  Ãºnica vez cada

  â†’  A  travessia  nÃ£o  define  nenhuma ordem prÃ©â€estabelecida de
  visita, de modo que hÃ¡, em cada grafo n! travessias  possÃ­veis,
  onde n Ã© a soma do nÃºmero de vÃ©rtices com o nÃºmero de arestas

  â†’  As travessias elementares sÃ£o a travessia por extensÃ£o (BFS,
  breadthâ€first search) e  a  travessia  por  profundidade  (DFS,
  depthâ€first search)

  â†’  Ambas  travessias utilizam a mesma ideia fundamental: marcar
  os vÃ©rtices jÃ¡ visitados para que os mesmos nÃ£o sejam visitados
  mais de uma vez, alÃ©m de possibilitar a conclusÃ£o da travessia

[4mTravessia[24m [4mpor[24m [4mextensÃ£o[0m

  â†’  Ã‰  a  mais  apropriada  nos casos onde a ordem de visita dos
  vÃ©rtices nÃ£o importa e se o objetivo  Ã©  determinar  o  caminho
  mais curtos em grafos nÃ£o ponderados

  â†’  Para  a  implementaÃ§Ã£o,  Ã© necessÃ¡rio manter um registro dos
  vÃ©rtices jÃ¡ visitados

  â†’ Esta tarefa pode ser dividida em duas  etapas:  descobrir  um
  vÃ©rtice,  que  o  acontece  quando o algoritmo atinge o vÃ©rtice
  pela primeira vez, e processar um vÃ©rtice,  que  significa  reâ€
  alizar a travessia de todos os vÃ©rtices adjacentes

  â†’  Este registro pode ser feito atravÃ©s de um tipo enumerado ou
  dois vetores de boolenas

    Â· CÃ³digo: dfsâ€bfs.c, funÃ§Ãµes bfs() e initialize_search()

    Â· CÃ³digo: bfsteste.cpp

  â†’ A travessia pode ser customizada a partir das  implementaÃ§Ãµes
  das funÃ§Ãµes process_vertex(), process_edge() e valid_edge()

  â†’  O vetor parent do algoritmo bfs gera informaÃ§Ãµes sobre a esâ€
  trutura de parentesco dos vÃ©rtices, que pode ser utilizada para
  se determinar o menor caminho da raiz atÃ© o vÃ©rtice desejado

  â†’ A raiz serÃ¡ o vÃ©rtice onde terÃ¡ inÃ­cio o algoritmo

  â†’ O vÃ©rtice v que leva a descoberta de um novo vÃ©rtice w serÃ¡ o
  pai dele

  â†’ Se, a partir do vÃ©rtice deseja, for seguidos  os  pais,  serÃ¡
  montado o caminho mais curto da raiz ao vÃ©rtice

    Â· CÃ³digo: dfsâ€bfs.c, funÃ§Ã£o find_path()

    Â· CÃ³digo: bfsteste2.cpp

  â†’  O  caminho mais curto gerado pelo BFS sÃ³ Ã© vÃ¡lido se o ponto
  de partida for a raiz da travessia

  â†’ Este caminho sÃ³ Ã© o mais curto em grafos nÃ£o poderados

[4mTravessia[24m [4mpor[24m [4mprofundidade[0m

  â†’ A travessia por profundidade guarda semelhanÃ§as com  o  backâ€
  tracking em dois pontos: ambos avanÃ§am enquanto for possÃ­vel, e
  recuam uma etapa quando nÃ£o; sÃ£o mais facilmente  implementados
  com recursÃ£o

  â†’  Ela  pode ser implementada tambÃ©m como uma travessia por exâ€
  tensÃ£o que utiliza uma pilha ao invÃ©s de uma fila

    Â· CÃ³digo: dfsâ€bfs.c, funÃ§Ã£o dfs()

    Â· CÃ³digo: dfsteste.cpp

  â†’ As travessias inâ€ordem, prÃ©â€ordem e pÃ³sâ€ordem das Ã¡rvores  de
  busca binÃ¡ria sÃ£o exemplos de travessias por profundidade

[4mEncontrando[24m [4mciclos[0m

  â†’ A travessia em profundidade em grafos nÃ£o direcionados partiâ€
  ciona as arestas em dois grupos: arestas de  Ã¡rvore  e  arestas
  reversas

  â†’  As  arestas  de  Ã¡rvore  sÃ£o  as arestas que descobrem novos
  vÃ©rtices durante a travessia

  â†’ Arestas reversas (back edges) sÃ£o aquelas que apontam de volâ€
  ta aos ancestrais do nÃ³

  â†’  Arestas  reversas  permitem a detecÃ§Ã£o de ciclos em um grafo
  nÃ£o direcionados: se nÃ£o houver arestas reversas, o  grafo  nÃ£o
  tem  ciclos; se houver uma aresta reversa (x, y) onde y nÃ£o Ã© o
  pai de x, entÃ£o hÃ¡ um ciclo de y atÃ© x

    Â· CÃ³digo: cycle.cpp

[4mComponentes[24m [4mconectados[0m

  â†’ Um componente conectado de um grafo nÃ£o direcionado  Ã©  um  o
  maior  conjunto  possÃ­vel  de  vÃ©rtices  tal  que hÃ¡ um caminho
  possÃ­vel entre todos os pares de vÃ©rtices

  â†’ O grafo pode ser representado por  uma  sÃ©rie  de  peÃ§as  deâ€
  sconectadas, onde cada peÃ§a Ã© um componente conectado

  â†’ Problemas complexos podem ser reduzidos ao problema de se deâ€
  terminar o nÃºmero de componentes conectados, como se hÃ¡ soluÃ§Ã£o
  para  uma  determinada configuraÃ§Ã£o do cubo Rubik ou do jogo de
  15 peÃ§as com um espaÃ§o livre

  â†’ Um componente conectado pode ser descoberto  atravÃ©s  de  uma
  travessia  por  extensÃ£o  ou por profundidade: como a ordem nÃ£o
  importa, todos os vÃ©rtices encontrados sÃ£o partes de  um  mesmo
  componente conectado

  â†’  Basta  comeÃ§ar  do primeiro vertice, determinar o componente
  conectado, e passar para o prÃ³ximo  vÃ©rtice  nÃ£o  encontrado  e
  iniciar  nova  travessia, atÃ© que todos os vÃ©rtices tenham sido
  encontrados

    Â· CÃ³digo: components.cpp

[4mOrdenaÃ§Ã£o[24m [4mTopolÃ³gica[0m

  â†’ A ordenaÃ§Ã£o topolÃ³gica Ã© uma operaÃ§Ã£o fundamental  em  grafos
  direcionados acÃ­clicos (DAGs, em inglÃªs)

  â†’ Ela constrÃ³i uma ordenaÃ§Ã£o dos vÃ©rtices de tal modo que todas
  as arestas direcionadas seguem da esquerda para a direita

  â†’ Ela fornece um modo de processar cada vÃ©rtice antes de  qualâ€
  quer um de seus sucessores

  â†’  Ela pode ser implementada atravÃ©s de uma variaÃ§Ã£o da travesâ€
  sia por profundidade, ou atravÃ©s de  um  algoritmo  baseado  na
  anÃ¡lise do nÃºmero de arestas que chegam ao vÃ©rtice

  â†’  Se  nenhuma aresta chega ao vÃ©rtice, ele tem grau de chegada
  igual a zero, e pode ser colocado na primeira posiÃ§Ã£o da  ordeâ€
  naÃ§Ã£o topolÃ³gica

  â†’  A  "remoÃ§Ã£o"  das arestas de chegada cria novos vÃ©rtices com
  grau de chegada iguais a zero, permitindo que o  processo  conâ€
  tinue atÃ© que todos os vÃ©rtices tenham sido posicionados

    Â· CÃ³digo: topsort.c













































