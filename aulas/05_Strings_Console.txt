
                             [1mStrings[0m


[4mCÃ³digos[24m [4mde[24m [4mcaracteres[0m

  â†’ Os cÃ³digos de caracteres sÃ£o funÃ§Ãµes entre nÃºmeros inteiros e
  os sÃ­mbolos de um determinado alfabeto

  â†’ Como  os  computadores  sÃ£o  projetados  para  trabalhar  com
  nÃºmeros, eles processam textos se referindo a estas associaÃ§Ãµes

  â†’ O padrÃ£o ASCII (American Standard Code for Information Interâ€
  change) Ã© um cÃ³digo de caracteres de um byte  que  associa  2^7
  caracteres

  â†’  No  padrÃ£o  ASCII, o bit mais significativo Ã© sempre igual a
  zero

  â†’  O  mapeamento  entre  os  nÃºmeros  e  os  caracteres  nÃ£o  Ã©
  aleatÃ³rio, e guarda importantes propriedades, como:
    Â· Os caracteres nÃ£o imprimÃ­veis ou tem os trÃªs primeiros bits
    nulos ou os sete Ãºltimos iguais a 1

    Â· As letras minÃºsculas e maiÃºsculas sÃ£o  organizadas  sequenâ€
    cialmente

    Â· A posiÃ§Ã£o relativa de uma letra no alfabeto pode ser obtida
    atravÃ©s da subtraÃ§Ã£o do caractere inicial (â€™aâ€™ para  minÃºscuâ€
    las e â€™Aâ€™ para maiÃºsculas)

    Â·  Esta manipulaÃ§Ã£o tambÃ©m pode ser utilizada para conversÃµes
    de maiÃºsculo para minÃºsculo e viceâ€versa

    Â· Algoritmos de ordenaÃ§Ã£o  utilizarÃ£o  estes  cÃ³digos  subjaâ€
    centes,  de modo que os nÃºmeros predecerÃ£o as maiuscÃºlas e as
    minÃºsculas, nesta ordem

    Â· Os caracteres de nova linha (LF, cÃ³digo 10)  e  retorno  do
    carro  (CR,  cÃ³digo  13) representam quebras de linha em Winâ€
    dows, enquanto em Linux utilizaâ€se apenas  o  CR.  Isto  pode
    gerar problemas de visualizaÃ§Ã£o de arquivos de texto entre os
    dois sistemas

  â†’ Outros mapeamentos, como o Unicode, podem  utilizar  dois  ou
  mais  bytes por caractere, e sÃ£o capazes de representar os outâ€
  ros  idiomas  como  maior  nÃºmero  de  caracteres   (portuguÃªs,
  japonÃªs, etc)

  â†’  Em C e C++, o tipo primitivo char ocupa apenas um byte. Para
  maiores caracteres, o C++  tem  o  tipo  wchar_t  (wide  char).
  QuestÃµes  de diferenÃ§as de codificaÃ§Ã£o e internacionalizaÃ§Ã£o de
  cÃ³digos devem ser tratadas com atenÃ§Ã£o e cuidado

[4mRepresentaÃ§Ã£o[24m [4mde[24m [4mstrings[0m

  â†’ Em geral, strings sÃ£o sequÃªncias ordenadas de caracteres

  â†’ Cada linguagem aborda strings de maneiras distintas, e Ã©  imâ€
  portante  conhecer estas diferenÃ§as para evitar possÃ­veis probâ€
  lemas

  â†’ Em C/C++, strings sÃ£o representados por arrays de  caracteres
  terminados com o caractere nulo (0, zero). A falta deste caracâ€
  tere delimitador pode levar a erros nos algoritmos que  manipuâ€
  lam as strings

  â†’ Por conta do delimitador, o espaÃ§o alocado para estas strings
  deve ser igual ao nÃºmero de caracteres desejados mais  um.  NÃ£o
  reservar este espaÃ§o pode levar aos erros jÃ¡ citados

  â†’ Outra maneira de se representar strings Ã© reservar a primeira
  posiÃ§Ã£o do vetor para codificar o tamanho da string,  removendo
  a necessidade do caractere terminador

  â†’  A  vantagem  desta abordagem Ã© que o array carrega consigo a
  informaÃ§Ã£o sobre o seu tamanho, o que nÃ£o acontece na primeira

  â†’ Supostamente esta Ã© a forma que o Java utiliza para implemenâ€
  tar as strings internamente

  â†’  Uma  terceira forma Ã© utilizar uma lista encadeada de caracâ€
  teres

  â†’ Esta forma Ã© evitada, por conta do gasto extra de memÃ³ria com
  os ponteiros da lista

  â†’  Contudo,  esta  forma  Ã© apropriada nos casos onde hÃ¡ vÃ¡rias
  inserÃ§Ãµes ou remoÃ§Ãµes de caracteres  em  posiÃ§Ãµes  diversas  da
  string

  â†’  A  representaÃ§Ã£o  mais adequada depende do contexto em que a
  string serÃ¡ utilizada. QuestÃµes a serem analisadas envolvem:

    Â· Qual representaÃ§Ã£o utiliza menos espaÃ§o em memÃ³ria?

    Â· Quais representaÃ§Ãµes restringem as possibilidades de repreâ€
    sentaÃ§Ãµes das strings?

    Â·  Quais representaÃ§Ãµes permitem acesso aleatÃ³rio imediato ao
    iâ€Ã©simo caractere?

    Â· Qual representaÃ§Ã£o permite checar se a posiÃ§Ã£o i Ã©  ou  nÃ£o
    vÃ¡lida  na  string  de forma eficiente, evitando erros de inâ€
    dexaÃ§Ã£o?

    Â· Qual representaÃ§Ã£o  permite  a  inserÃ§Ã£o  ou  a  remoÃ§Ã£o  o
    iâ€Ã©simo elemento de forma eficiente?

    Â· Qual Ã© mais eficiente se as strings tem um capacidade mÃ¡xiâ€
    ma prÃ©â€determinada?

[4mExemplo:[24m [4mCorporate[24m [4mRenamings[0m

  â†’ DescriÃ§Ã£o do problema: pg 59 do livro texto

  â†’ Uma estratÃ©gia de leitura das strings consiste em ler a linha
  de  input  inteira,  e depois varrer a linha em busca as inforâ€
  maÃ§Ãµes  desejadas  (ver  mÃ©todos  read_changes()  e  read_quotâ€
  ed_string() no arquivo name.c)

  â†’  TambÃ©m  Ã© necessÃ¡rio determinar se uma determinada string se
  encontra ou nÃ£o em uma linha de texto (ver  mÃ©todo  findmatch()
  no name.c)








