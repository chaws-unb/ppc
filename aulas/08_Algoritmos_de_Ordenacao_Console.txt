
                     [1mAlgoritmos de OrdenaÃ§Ã£o[0m


[4mSobre[24m [4mos[24m [4malgoritmos[24m [4mde[24m [4mordenaÃ§Ã£o[0m

  â†’ Existem diversos algoritmos de ordenaÃ§Ã£o

  â†’  O estudo destes algoritmos Ã© importante devido as ideias que
  cada um apresenta

  â†’ Cada algoritmo tem suas particularidades, e  apresentam  proâ€
  priedades importantes que devem ser identificadas e estudadas

[4mOrdenaÃ§Ã£o[24m [4mpor[24m [4mseleÃ§Ã£o[0m

  â†’  Este algoritmo separa o vetor em duas partes: a ordenada e a
  nÃ£o ordenada

  â†’ Cada iteraÃ§Ã£o determina o menor elemento da regiÃ£o nÃ£o  ordeâ€
  nada, e o move para o fim da regiÃ£o ordenada

  â†’ O nÃºmero de comparaÃ§Ãµes Ã© alto, mas o nÃºmero de trocas de elâ€
  ementos Ã© baixo (n â€ 1)

  â†’ A ordem de complexidadeÃ© O(n^2)
    CÃ³digo: sorting.c (selection_sort())

  â†’ Este Ã© um algoritmo estÃ¡vel (isto Ã©, mantÃ©m as posiÃ§Ãµes relaâ€
  tivas  caso  exista dois elementos iguais segundo o critÃ©rio de
  comparaÃ§Ã£o)

[4mOrdenaÃ§Ã£o[24m [4mpor[24m [4minserÃ§Ã£o[0m

  â†’ Este algoritmo tambÃ©m separa o vetor em duas regiÃµes: ordenaâ€
  da e nÃ£o ordenada

  â†’  Em cada iteraÃ§Ã£o, o prÃ³ximo elemento da parte nÃ£o ordenada Ã©
  inserido na posiÃ§Ã£o adequada da parte ordenada

  â†’ A proposta do algoritmo Ã© minimizar o nÃºmero de trocas  entre
  elementos

  â†’ Ã‰ bastante eficiente quando o vetor estÃ¡ parcialmente ordenaâ€
  do
    Â· CÃ³digo: sorting.c (insertion_sorting.c)

  â†’ Este algoritmo tambÃ©m Ã© estÃ¡vel

[4mOrdenaÃ§Ã£o[24m [4mrÃ¡pida[24m [4m(quicksort)[0m

  â†’ O algoritmo reduz o problema de ordenar um vetor  em  ordenar
  dois vetores menores, a partir de uma partiÃ§Ã£o

  â†’ A partiÃ§Ã£o separa os elementos do vetor em dois conjuntos: os
  menores ou iguais a um valor pivÃ´, e os elementos que  sÃ£o  esâ€
  tritamente maiores

  â†’ Como os elementos dos vetores nÃ£o precisam ser movidos para o
  outro conjunto apÃ³s a partiÃ§Ã£o, os subvetores resultantes podem
  ser ordenados independentemente

  â†’  A  implementaÃ§Ã£o  fica mais simples se mantidos os registros
  dos Ã­ndices do primeiro e do Ãºltimo elemento do vetor
    Â· CÃ³digo: sorting.c (quicksort.c)

  â†’ Este algoritmo nÃ£o Ã© estÃ¡vel

[4mExemplo[24m [4mde[24m [4mordenaÃ§Ã£o:[24m [4mRating[24m [4mthe[24m [4mField[0m

  â†’ pÃ¡g. 85 do livro texto

    Â· CÃ³digo: polly.c

  â†’ Observe a funÃ§Ã£o de comparaÃ§Ã£o implementada e seu uso em conâ€
  junto com o qsort() da stdlib.h
























































