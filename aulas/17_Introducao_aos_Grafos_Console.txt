
                      [1mIntroduÃ§Ã£o aos Grafos[0m


[4mTipos[24m [4mde[24m [4mGrafos[0m

  â†’  Um grafo G = (V, E) Ã© definido por um conjunto de vÃ©rtices V
  e um conjunto de arestas E  (edges,  em  inglÃªs),  definido  de
  pares ordenados ou nÃ£o de vÃ©rtices

  â†’  Por  exemplo, a malha viÃ¡ria de um estado poderia ser repreâ€
  sentada por um grafo onde as  cidades  sÃ£o  os  vÃ©rtices  e  as
  estradas sÃ£o as arestas

  â†’  Os  grafos  podem  ser  classificados  segundo  os seguintes
  critÃ©rios:

    â†’ Direcionado ou NÃ£oâ€Direcionado  (Dirigido  ou  Digrafo):  o
    grafo  nÃ£o Ã© direcionado se o fato da aresta (x, y) pertencer
    a E implica que a aresta (y, x) tambÃ©m  pertence.  Caso  conâ€
    trÃ¡rio, o grafo Ã© direcionado

    â†’  Ponderado  ou  NÃ£o  Ponderado: Em grafos poderados, a cada
    vÃ©rtice de G Ã© associado um valor nÃºmerico, denominado  peso.
    Exemplos de peso, na prÃ¡tica: distÃ¢ncia, tempo de viagem, caâ€
    pacidade mÃ¡xima, etc.

    â†’ CÃ­clico ou AcÃ­clico: grÃ¡ficos acÃ­clicos nÃ£o podem ter  nenâ€
    hum  ciclo.  Ãrvores  sÃ£o  grafos nÃ£oâ€direcionados acÃ­clicos.
    Grafos acÃ­clicos direcionados sÃ£o denominados DAG

    â†’ Simples e NÃ£oâ€simples: Um autoloop Ã© uma aresta (x, x)  que
    envolve  apenas  um  vÃ©rtice;  e uma multiaresta (x, y) Ã© uma
    aresta que aparece mais de uma vez no grafo. Se o  grafo  nÃ£o
    tem autoloops nem multiarestas ele Ã© denominado simples

    â†’  Embutidos  ou TopolÃ³gicos: o grÃ¡fo Ã© embutido se foram deâ€
    terminadas posiÃ§Ãµes geomÃ©tricas para os vÃ©rtices  e  arestas.
    Caso contrÃ¡rio o grafo Ã© topolÃ³gico

    â†’  ImplÃ­cito  ou  ExplÃ­cito:  os  grafos  implÃ­citos sÃ£o conâ€
    struÃ­dos a medida que sÃ£o utilizados,  enquanto  que  os  exâ€
    plÃ­citos sÃ£o construÃ­dos na Ã­ntegra antes de sua utilizaÃ§Ã£o

    â†’  Rotulados  ou  NÃ£oâ€Rotulados:  em  grafos  rotulados, cada
    vÃ©rtice recebe um nome Ãºnico, que o distingue de todos os deâ€
    mais vÃ©rtices

[4mEstruturas[24m [4mde[24m [4mDados[24m [4mpara[24m [4mGrafos[0m

  â†’  HÃ¡ vÃ¡rias formas de se representar um grafo G = (V, E) com n
  vÃ©rtices e m arestas

    â†’ Matriz de adjacÃªncia: G pode ser representado por  uma  maâ€
    triz M de dimensÃµes n x n, onde o elemento M_ij = 1 se (i, j)
    Ã© uma aresta de G, ou M_ij = 0, caso contrÃ¡rio. As  vantagens
    desta representaÃ§Ã£o sÃ£o:
      Â·  Resposta rÃ¡pida para perguntas do tipo: "(i, j) pertence
      a G?"

      Â· InserÃ§Ã£o e remoÃ§Ã£o rÃ¡pida de arestas

    â†’ A principal desvantagem Ã© o uso excessivo de memÃ³ria,  pois
    representa arestas que nÃ£o fazem parte do grafo

    â†’  Lista de adjacÃªncia em listas: Uma forma mais eficiente de
    representar grafos esparsos (com poucas arestas)  Ã©  utilizar
    listas encadeadas para armazenar os vizinhos de cada vÃ©rtice,
    sendo que cada vÃ©rtice Ã© posicionado em uma lista tambÃ©m

    â†’ Ã‰ mais complicado responder a pergunta  "(i,j)  pertence  a
    G?"  do  que  com  matrizes  de  adjacÃªncias,  porÃ©m o uso de
    memÃ³ria Ã© muito menor

    â†’ Lista de adjacÃªncia em matrizes: Ã© uma adaptaÃ§Ã£o da  repreâ€
    sentaÃ§Ã£o  anterior,  porÃ©m colocando as listas de adjacÃªncias
    em uma matriz. Esta representaÃ§Ã£o tambÃ©m  recebe  o  nome  de
    representaÃ§Ã£o estrela

    â†’ Tem como vantagem o fato de nÃ£o precisar de ponteiros: basâ€
    ta codificar o nÃºmero de elementos da lista na  primeira  enâ€
    trada  de  cada  linha  da  matriz,  e listar os elementos em
    seguida

    â†’ PorÃ©m, tem as piores caracterÃ­sticas dos dois mÃ©todos anteâ€
    riores:  grande  uso  de memÃ³ria e necessidade de buscas para
    identificar a presenÃ§a ou nÃ£o de uma aresta

    â†’ Ainda assim, Ã© uma estrutura simples, fÃ¡cil de usar  e  imâ€
    plementar,  e a memÃ³ria pode ser melhor utilizada alocandoâ€se
    dinamicamente cada linha, evitando o desperdÃ­cio de memÃ³ria

      Â· CÃ³digo: graph.h

    â†’ Tabela de arestas: uma estrutura ainda mais simples para  a
    representaÃ§Ã£o de grafos Ã© um vetor ou lista de arestas. Emboâ€
    ra nÃ£o seja flexÃ­vel para responder imediatamente  sobre  adâ€
    jacÃªncias, funciona bem em situaÃ§Ãµes mais simples

[4mAlgoritmos[24m [4mbÃ¡sicos[24m [4mem[24m [4mgrafos[0m

  â†’  InicializaÃ§Ã£o:  na representaÃ§Ã£o por lista de adjacÃªncias em
  uma matriz (conforme a estrutura  apresentada  em  graph.h),  a
  inicializaÃ§Ã£o  deve configurar um estado inicial correto para o
  grafo, definindo o nÃºmero de vÃ©rtices e arestas como zero, alÃ©m
  de zerar o grau (nÃºmero de vÃ©rtices adjacentes) de cada vÃ©rtice

    Â· CÃ³digo: graph.c

  â†’  InserÃ§Ã£o  de  uma nova aresta: esta inserÃ§Ã£o deve atentar ao
  fato do grafo ser direcionado ou nÃ£o,  que  pode  acarretar  na
  inserÃ§Ã£o  da aresta (y, x) a cada inserÃ§Ã£o de (x, y). Basta inâ€
  serir, o valor de y na primeira posiÃ§Ã£o livre do vetor  de  adâ€
  jacÃªncias de x, e atualizar o nÃºmero de arestas

  â†’  Leitura  de  um arquivo: basta inicializar o grafo e, imporâ€
  tante, inicializar o nÃºmero  de  vÃ©rtices.  DaÃ­  Ã©  sÃ³  ler  as
  arestas do arquivo, inserindo uma por vez

  â†’ ImpressÃ£o: uma maneira possÃ­vel de imprimir um grafo Ã© exibir
  o nÃºmero associado a cada vÃ©rtice e, em seguida, sua  lista  de
  adjacÃªncias

    Â·   CÃ³digo:   main.c,   main.cpp,   (entradas:   edges.txt  e
    edges_cpp.txt)







