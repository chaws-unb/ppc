
                 [1mEstruturas de dados elementares[0m


[4mEstruturas[24m [4mde[24m [4mdados[24m [4mimportantes[0m

  â†’  Pilhas,  filas, dicionÃ¡rios, filas de prioridade e conjuntos
  sÃ£o estruturas de dados fundamentais em programaÃ§Ã£o

  â†’ C++ e Java oferecem, em suas  bibliotecas  padrÃ£o,  implemenâ€
  taÃ§Ãµes destas estruturas

  â†’ Contudo, o conhecimento da implementaÃ§Ãµes destas estruturas e
  suas operaÃ§Ãµes bÃ¡sicas sÃ£o  de  grande  valia,  por  conta  das
  ideias e tÃ©cnicas inerentes a estas implementaÃ§Ãµes

[4mPilhas[0m

  â†’ SÃ£o estruturas do tipo LIFO (last in, first out)

  â†’ As operaÃ§Ãµes abstratas de uma pilha incluem

    Â· push(x, s): Insere um item x na pilha

    Â· pop(s): Retorna o elemento do topo da pilha

    Â· initialize(s): Cria uma pilha vazia

    Â· full(s): Retorna verdadeiro caso a pilha esteja cheia*

    Â· empty(s): Retorna verdadeiro caso a pilha esteja vazia

  * podeâ€se considerar que o mÃ©todo full() revela detalhes da imâ€
  plementaÃ§Ã£o e, assim, nÃ£o pode fazer parte da interface abstraâ€
  ta de uma pilha

[4mImplementaÃ§Ãµes[24m [4mde[24m [4mpilhas[0m

  â†’  HÃ¡  duas formas bÃ¡sicas de se implementar uma pilha: com veâ€
  tores e com listas encadeadas

  â†’ Com vetores, Ã© necessÃ¡rio manter  o  registro  do  Ã­ndice  do
  topo.  AlÃ©m  disso,  a pilha passa a ter uma capacidade mÃ¡xima,
  igual ao tamanho do vetor

  â†’ A segunda forma Ã© utilizar listas encadeadas.  O  tamanho  da
  pilha  fica restrito apenas a quantidade de memÃ³ria disponÃ­vel,
  porÃ©m a implementaÃ§Ã£o utiliza mais espaÃ§o em memÃ³ria do  que  a
  anterior

[4mFilas[0m

  â†’ Filas sÃ£o estruturas FIFO (first in, first out)

  â†’  Exemplos  prÃ¡ticos  de  filas sÃ£o filas em bancos e decks de
  cartas

  â†’ OperaÃ§Ãµes abstratas de uma fila incluem:

    Â· enqueue(x, q): insere o elemento x na fila q

    Â· dequeue(q): retorna (e remove) o elemento do inÃ­cio de q

    Â· initialize(q): Cria uma fila vazia

    Â· full(q): Retorna verdadeiro caso a fila esteja cheia

    Â· empty(q): Retorna verdadeiro caso a fila esteja vazia

[4mImplementaÃ§Ãµes[24m [4mde[24m [4mfilas[0m

  â†’ Filas sÃ£o mais difÃ­ceis de implementar do que pilhas

  â†’ Uma implementaÃ§Ã£o possÃ­vel Ã© utilizar um array circular, manâ€
  tendo o registro do inÃ­cio e fim da fila

  â†’ Exemplo da implementaÃ§Ã£o com array circular:
    Â· queue.h
    Â· queue.c

  â†’  Contudo,  a  implementaÃ§Ã£o  utilizando listas duplamente enâ€
  cadeadas Ã© mais fÃ¡cil do que a anterior baseada em arrays

[4mDicionÃ¡rios[0m

  â†’ DicionÃ¡rios sÃ£o estruturas que  permitem  recuperar  dados  a
  partir do conteÃºdo, e nÃ£o da posiÃ§Ã£o dos dados em memÃ³ria

  â†’ OperaÃ§Ãµes bÃ¡sicas de dicionÃ¡rios incluem:

    Â· insert(x, d): insere o elemento x no dicionÃ¡rio d

    Â· delete(x, d): remove o elemento x de d

    Â· search(k, d): retorna o elemento de d com a chave k, se exâ€
    istir

[4mImplementaÃ§Ãµes[24m [4mde[24m [4mdicionÃ¡rios[0m

  â†’ Existem muitas formas de se implementar um dicionÃ¡rio: listas
  encadeadas  (ordenadas  ou  nÃ£o),  vetores  (ordenados ou nÃ£o),
  Ã¡rvores AVL e redâ€black, hashing, etc

  â†’ O importante  Ã©  balancear  o  custo  de  execuÃ§Ã£o  das  trÃªs
  operaÃ§Ãµes,  sendo  esta  decisÃ£o baseada no contexto onde o diâ€
  cionÃ¡rio deverÃ¡ ser utilizado

  â†’ O quanto o dicionÃ¡rio irÃ¡ variar durante a execuÃ§Ã£o pode auxâ€
  iliar nesta decisÃ£o

[4mTipos[24m [4mde[24m [4mdicionÃ¡rios[0m

  â†’  DicionÃ¡rios  estÃ¡ticos nÃ£o variam depois de construÃ­dos. Asâ€
  sim, tem suporte Ã  busca, mas nÃ£o Ã  inserÃ§Ã£o e remoÃ§Ã£o

  â†’ A implementaÃ§Ã£o mais apropriada para dicionÃ¡rios estÃ¡ticos  Ã©
  atravÃ©s de vetores

  â†’  Se  o  nÃºmero de elementos for maior do que 100, vale a pena
  considerar a possibilidade de ordenar o vetor e utilizar buscas
  binÃ¡rias. Para valores inferiores, a busca linear Ã© suficiente

  â†’  DicionÃ¡rios  semiâ€dinÃ¢micos  suportam tanto a busca quanto a
  inserÃ§Ã£o, mas nÃ£o a remoÃ§Ã£o

  â†’ Se o nÃºmero mÃ¡ximo de elementos a serem inseridos Ã©  conheciâ€
  do,  a implementaÃ§Ã£o baseada em vetores Ã© suficiente; caso conâ€
  trÃ¡rio, Ã© mais adequado o uso de listas encadeadas

  â†’ Tabelas hash constituem uma excelente alternativa  para  conâ€
  struir dicionÃ¡rios, principalmente se nÃ£o hÃ¡ suporte Ã  remoÃ§Ã£o

  â†’  DicionÃ¡rios  dinÃ¢micos  suportam  todas  as  trÃªs  operaÃ§Ãµes
  bÃ¡sicas

  â†’ Tabelas hash tambÃ©m podem ser utilizadas  neste  caso,  desde
  que  a resoluÃ§Ã£o de colisÃµes seja feita por encadeamento, e nÃ£o
  por endereÃ§amento aberto

  â†’ No encadeamento cada entrada da  tabela  Ã©  associada  a  uma
  lista  encadeada, e elementos que colidem sÃ£o inseridos/removiâ€
  dos destas listas

[4mFilas[24m [4mcom[24m [4mprioridades[0m

  â†’ Filas com prioridades sÃ£o filas onde  os  elementos  tem  uma
  relaÃ§Ã£o  de  prioridade  que determina o prÃ³ximo elemento a ser
  removido

  â†’ OperaÃ§Ãµes sobre filas com prioridades incluem:

    Â· insert(x, p): insere o elemento x na fila com prioridades p

    Â· maximum(p): retorna o elemento com maior prioridade da fila

    Â· extractMax(p): extrai e remove o elemento com maior prioriâ€
    dade

  â†’  A  implementaÃ§Ã£o  de  uma fila com prioridades deve levar em
  consideraÃ§Ã£o o custo/benefÃ­cio entre a inserÃ§Ã£o e a remoÃ§Ã£o  de
  seus elementos

[4mConjuntos[0m

  â†’ Conjuntos (tecnicamente, subconjuntos) sÃ£o coleÃ§Ãµes nÃ£o ordeâ€
  nadas de elementos escolhidos de um conjunto universal U

  â†’ OperaÃ§Ãµes bÃ¡sicas sobre conjuntos incluem:

    Â· member(x, S): retorna verdadeiro se x pertenca ao  conjunto
    S

    Â· union(A, B): constrÃ³i o conjunto uniÃ£o AUB

    Â· intersection(A, B): constrÃ³i a interseÃ§Ã£o de A e B

    Â· insert(x, S): insere x no conjunto S

    Â· delete(x, S): remove x do conjunto S

[4mImplementaÃ§Ãµes[24m [4mde[24m [4mconjuntos[0m

  â†’  Conjuntos  sÃ£o  implementados,  em  geral,  a  partir de diâ€
  cionÃ¡rios, sendo que dicionÃ¡rios ordenados facilitam  a  impleâ€
  mentaÃ§Ã£o das operaÃ§Ãµes de uniÃ£o e interseÃ§Ã£o

  â†’  Se  o  conjunto  provÃ©m  de  um  conjunto universo pequeno e
  imutÃ¡vel, vetores podem ser uma boa escolha  para  a  implemenâ€
  taÃ§Ã£o do conjunto

  â†’  Dependendo do nÃºmero de elementos de U, o subconjunto S pode
  ser implementado como um vetor de bits

[4mEstruturas[24m [4mde[24m [4mdados[24m [4mem[24m [4mC++[0m

  â†’ A biblioteca padrÃ£o de templates (STL) do C++ provÃª a  impleâ€
  mentaÃ§Ã£o  das estruturas citadas, de forma independente do tipo
  de dado armazenado

  â†’ O cabeÃ§alho padrÃ£o para esta biblioteca Ã© o â€™stlâ€™, sendo  que
  hÃ¡ cabeÃ§alhos especÃ­ficos para cada estrutura

  â†’  Para  pilhas,  sÃ£o  definidos  os mÃ©todos S.push(), S.top(),
  S.pop() e S.empty(), sendo que top() consulta, mas nÃ£o  remove,
  o elemento do topo da pilha, enquanto pop() remove, mas nÃ£o reâ€
  torna, o topo

  â†’ Para filas, estÃ£o disponÃ­veis os mÃ©todos Q.front(), Q.back(),
  Q.push(), Q.pop() e Q.empty()

  â†’  Os  dicionÃ¡rios  suportam  os  mÃ©todos H.erase(), H.find() e
  H.insert(), sendo os hash_map uma das variantes disponÃ­veis

  â†’ Filas com prioridades estÃ£o  em  <priority_queue>  e  tem  os
  mÃ©todos Q.top(), Q.push(), Q.pop() e Q.empty()

  â†’ Os conjuntos sÃ£o representados por estruturas associativas, e
  suportam operaÃ§Ãµes set_union e set_intersection dentro da  bibâ€
  lioteca de algoritmos

[4mExemplo:[24m [4mGoing[24m [4mto[24m [4mWar++[0m

  â†’ DescriÃ§Ã£o do problema: pg 34 do livro texto

  â†’ Leia o problema atentamente: separe o contexto dos dados relâ€
  evantes. Uma estratÃ©gia Ã© fazer uma leitura inicial do problema
  e em, seguida, uma leitura detalhada

  â†’  NÃ£o  assuma nada do que nÃ£o foi descrito no texto: ordem dos
  dados, limites, propriedades, etc

  â†’ NÃ£o se preocupe com otimizaÃ§Ãµes a menos que seja estritamente
  necessÃ¡rio, isto Ã©, caso receba um TLE do juiz

  â†’ Como um deck pode ser representado eficientemente?

    Â· Filas (tirar do topo e inserir no final)

    Â·  As cartas podem ser representadas por pares de caracteres,
    ou Ã­ndices numÃ©ricos (atravÃ©s de uma funÃ§Ã£o que mapeia  valor
    e  suite  em  um  nÃºmero Ãºnico.  Veja os mÃ©todos rank_card(),
    suit() e value() em war.c)






















