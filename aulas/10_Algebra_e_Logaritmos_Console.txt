
                      [1mÃlgebra e Logaritmos[0m


[4mÃlgebra[0m

  â†’ A Ã¡lgebra consiste no estudo de grupos e anÃ©is

  â†’  Em  nÃ­vel  de segundo grau, a Ã¡lgebra se limita ao estudo de
  equaÃ§Ãµes e polinÃ´mios

  â†’ Os polinÃ´mios sÃ£o expressÃµes do tipo p(x)  =  c_0  +  c_1x  +
  c_2x^2  + ..., onde x Ã© a variÃ¡vel e c_i o coeficiente do termo
  x^i

  â†’ O grau de um polinÃ´mio Ã© o maior i tal que c_i Ã© diferente de
  zero

[4mManipulaÃ§Ã£o[24m [4mde[24m [4mpolinÃ´mios[0m

  â†’  A  implementaÃ§Ã£o mais comum de um polinÃ´mio de grau n em uma
  variÃ¡vel Ã© um vetor de n + 1 coeficientes (do c_0 ao c_n)

  â†’ Esta representaÃ§Ã£o facilita  a  implementaÃ§Ã£o  das  operaÃ§Ãµes
  bÃ¡sicas sobre polinÃ´mios, descritas a seguir

  â†’  AvaliaÃ§Ã£o:  determinar  o valor p(x) para um x dado pode ser
  feito por forÃ§a bruta, calculando cada fator c_ix^i independenâ€
  temente  e somando os resultados obtidos. O problema Ã© que esta
  abordagem leva a O(n^2) multiplicaÃ§Ãµes

  â†’ Para implementar esta avaliaÃ§Ã£o em O(n), basta  observar  que
  x^i  = x * x^{iâ€1}, comeÃ§ar pelos termos de menor grau e manter
  o registro da potÃªncia jÃ¡ calculada

  â†’ TambÃ©m Ã© possÃ­vel utilizar a regra de Horner:

    c_nx^n + c_{nâ€1}x^{nâ€1} + ... + c_0 = ((c_nx  +  c_{nâ€1})x  +
    ...)x + c_0

  â†’   AdiÃ§Ã£o/SubtraÃ§Ã£o:  estas  operaÃ§Ãµes  sÃ£o  mais  simples  em
  polinÃ´mios do que grandes inteiros, uma vez que nÃ£o hÃ¡ overflow
  em cada termo. Basta somar e subtrair termo a termo

  â†’  MultiplicaÃ§Ã£o: o produto entre p(x) e q(x) Ã© a soma dos proâ€
  dutos de todos os termos de p por todos os termos de q, isto Ã©,

    p(x)q(x)  =  sum_{i=0}^{grau  de  p}  sum_{j=0}^{grau  de  q}
    (c_ic_j)x^{i+j}

   â†’ Este soma de produtos termo a termo Ã© denominada convoluÃ§Ã£o

   â†’  Outros exemplos de convoluÃ§Ã£o sÃ£o o produto de inteiros e a
   busca de uma string em um texto

   â†’ A FFT (Fast Fourier Transform) calcula convoluÃ§Ãµes em O(nlog
   n) ao invÃ©s de O(n^2)

   â†’ DivisÃ£o: os polinÃ´mios nÃ£o sÃ£o fechados para a divisÃ£o (isto
   Ã©, a divisÃ£o de dois polinÃ´mios pode resultar em uma expressÃ£o
   que  nÃ£o  Ã©  polinomial).  Levando isto em consideraÃ§Ã£o, a diâ€
   visÃ£o de polinÃ´mios Ã© semelhante a divisÃ£o de nÃºmeros inteiros

   â†’ Se o polinÃ´mio Ã© esparso (isto Ã©,  com  muitos  coeficientes
   nulos),  uma melhor representaÃ§Ã£o seria uma lista encadeada de
   pares coeficientes/grau

   â†’ Se o polinÃ´mio Ã© multivariado, os coeficientes podem ser arâ€
   mazenados  em matrizes. Por exemplo, para o polinÃ´mio bivariaâ€
   do, o elemento C[i][j] da matriz C representa o coeficiente do
   termos x^iy^j

   â†’  Dado  um polinÃ´mio p(x) e um nÃºmero t, o problema de enconâ€
   trar as raizes consiste em determinar todos os x tais que p(x)
   = t

   â†’  Se p(x) Ã© um polinÃ´mio de primeiro grau, a raiz Ãºnica Ã© x =
   (t â€ a_0)/a_1

   â†’ Se p(x) Ã© um polinÃ´mio de segundo grau, as duas raizes podem
   ser computadas pela expressÃ£o

    x = (â€a_1 +â€ sqrt{a_1^2 â€ 4a_2(a_0 â€ t)})/2a_2

  â†’  Para graus maiores, Ã© necessÃ¡rio utilizar mÃ©todos numÃ©ricos,
  como os mÃ©todos de Newton e Newtonâ€Raphson

  â†’ A ideia central deste mÃ©todos Ã© a busca binÃ¡ria:  se  f(x)  Ã©
  uma  funÃ§Ã£o monotonicamente crescente entre l e u, isto Ã©, f(i)
  <= f(j) para todos l <= i <= j <= u. Para encontrar uma raiz de
  f(x)  = t, compare f((l+u)/2) com t. Se t < f((l+u)/2), entÃ£o a
  raiz estÃ¡ entre l e (l+u)/2; caso contrÃ¡rio, a raiz estÃ¡  entre
  (l+u)/2  e u. Basta continuar atÃ© que o intervalo de busca seja
  pequeno o suficiente

  â†’  Este  mÃ©todo  pode  ser  utilizado  para   computar   raizes
  quadradas,  resolvendo  x^2 = t, no intervalo 1 e t, para qualâ€
  quer t >= 1

[4mLogaritmos[0m

  â†’ A funÃ§Ã£o logaritmo Ã© a inversas da exponencial,  isto  Ã©,  se
  b^x = y, entÃ£o log_b y = x

  â†’ O nÃºmero b Ã© a base do logaritmo

  â†’  Duas bases importantes historicamente sÃ£o e e 10. Logaritmos
  nestas bases sÃ£o escritos como ln x e log x

  â†’ Observe que sÃ£o verdadeiras as expressÃµes exp(ln  x)  =  x  e
  ln(exp x) = x

  â†’  Tabelas de logaritmos na base 10 eram utilizadas para multiâ€
  plicar grandes nÃºmeros, antes do advento das calculadoras

  â†’ A multiplicaÃ§Ã£o utilizava a propriedade  dos  logaritmos  que
  transforma produtos em somas: log_a xy = log_a x + log_a y

  â†’ Uma consequÃªncia desta propriedade Ã© que log_a n^b = blog_a n

  â†’  Combinadas,  estas  propriedades  permitem  calcular  a^b da
  seguinte forma:

    a^b = exp(ln(a^b)) = exp(bln a)

  â†’  Este  mÃ©todo  pode  ser  utilizado  para   computar   raizes
  quadradas, com b = 1/2

  â†’  Como as implementaÃ§Ãµes de exp e ln sÃ£o baseadas em expansÃµes
  da sÃ©rie de Taylor, de modo que erros de  arredondamento  podem
  fazer que expressÃµes como exp (0.5 ln 4) nÃ£o retorne exatamento
  2

  â†’ A mudanÃ§a  entre  bases  de  logaritmos  pode  ser  realizada
  atravÃ©s da expressÃ£o

    log_a b = log_c b / log_c a

[4mBibliotecas[24m [4mde[24m [4mnÃºmeros[24m [4mreais[0m

  â†’  Em  C,  a  biblioteca math.h provÃª as seguintes funÃ§Ãµes para
  nÃºmeros reais, dentre outras:

    Â· double floor(double x);
    Â· double ceil(double x);
    Â· double fabs(double x);
    Â· double sqrt(double x);
    Â· double cbrt(double x);
    Â· double exp(double x);
    Â· double log(double x);
    Â· double log10(double x);
    Â· double pow(double x);














































