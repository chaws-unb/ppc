
                          [1mBacktracking[0m


[4mForÃ§a[24m [4mbruta[0m

  â†’  O  desempenho atual dos computadores torna a forÃ§a bruta uma
  tÃ©cnica viÃ¡vel para a resoluÃ§Ã£o de problemas

  â†’ Basta atentar ao fato de que o nÃºmero  de  possibilidades  do
  problemas seja computacionalmente viÃ¡vel

  â†’ Numa aproximaÃ§Ã£o rude, um computador hoje pode processar cerâ€
  ca de um milhÃ£o de itens por segundo

  â†’ TambÃ©m Ã© eficaz desenvolver mÃ©todos que permitam a reduÃ§Ã£o do
  universo  de  possibilidades, descartando uma possibilidade tÃ£o
  logo ela se mostre invÃ¡lida

[4mBacktracking[0m

  â†’ Backtracking Ã© um mÃ©todo sistemÃ¡tico de iteraÃ§Ã£o sobre  todas
  as possÃ­veis configuraÃ§Ãµes de um espaÃ§o de busca

  â†’  Ã‰  uma  tÃ©cnica geral, que deve ser adaptada para cada apliâ€
  caÃ§Ã£o ou problema

  â†’ No caso geral, a soluÃ§Ã£o a Ã© um vetor a  =  (a_1,  a_2,  ...,
  a_n), onde cada a_i Ã© um elemento de um conjunto finito S_i

  â†’  Este  vetor  pode  representar um arranjo, onde a_i contÃ©m o
  iâ€Ã©simo elemento da permutaÃ§Ã£o; ou um subconjunto S_i, onde a_i
  Ã©  verdadeiro  se  o iâ€Ã©simo elemento do conjunto universo perâ€
  tence a S_i; ou uma sequÃªncia de movimentos em um jogo, por exâ€
  emplo

  â†’ Cada passo do backtracking comeÃ§a com uma soluÃ§Ã£o parcial a =
  (a_1, a_2, ..., a_k), e tenta ampliÃ¡â€la atravÃ©s  da  adiÃ§Ã£o  de
  uma novo elemento

  â†’  ApÃ³s  essa adiÃ§Ã£o Ã© necessÃ¡rio verificar se a continua sendo
  uma soluÃ§Ã£o: caso seja, ele pode ser processada, contada, etc

  â†’ caso contrÃ¡rio, deveâ€se checar se ainda hÃ¡ modos de  extender
  a  soluÃ§Ã£o  parcial:  se  houver,  continuar  no prÃ³ximo passo;
  senÃ£o, remova o Ãºltimo elemento de a e passe a  prÃ³xima  possiâ€
  bilidade, se existir

    Â· CÃ³digo: backtrack.c

  â†’  A  funÃ§Ã£o  is_a_solution(a,  k,  input)  verifica  se  as  k
  primeiras posiÃ§Ãµes do vetor formam uma soluÃ§Ã£o para o problema

  â†’ O parÃ¢metro input permite passar informaÃ§Ãµes gerais  sobre  o
  problema (como, por exemplo, o tamanho da soluÃ§Ã£o)

  â†’  A  funÃ§Ã£o  construct_candidates(a, k, input, c, ncandidates)
  preenche o vetor c com o conjunto completo  de  possÃ­veis  canâ€
  didatos  para a kâ€Ã©sima posiÃ§Ã£o de a, dado o conteÃºdo das k â€ 1
  posiÃ§Ãµes jÃ¡ preenchidas,  e  retorna  o  nÃºmero  de  candidatos
  atravÃ©s do parÃ¢metro ncandidates

  â†’  A  funÃ§Ã£o process_solution(a, k) trata a soluÃ§Ã£o encontrada,
  de acordo com o problema

  â†’ O backtracking garante a corretude atravÃ©s da  enumeraÃ§Ã£o  de
  todas as possibilidades, e a eficiÃªncia, nÃ£o visitando um mesmo
  estado mais de uma vez

  â†’ A recursÃ£o permite uma implementaÃ§Ã£o simples  e  elegante  do
  backtracking

[4mExemplo[24m [4mde[24m [4mbacktracking:[24m [4mConstruÃ§Ã£o[24m [4mde[24m [4mtodos[24m [4mos[24m [4msubconjuntos[0m

  â†’ O problema consiste em determinar todos os 2^n subconjuntos a
  partir d n elementos distintos

  â†’ Isto serÃ¡ feito atravÃ©s da iteraÃ§Ã£o de todos os possÃ­veis 2^n
  vetores  de n elementos de verdadeiro ou falso, onde o elemento
  i denota a presenÃ§a ou nÃ£o do iâ€Ã©simo elemento no subconjunto

  â†’ Na notaÃ§Ã£o de backtracking, S_k = {true, false}, e  a  Ã©  uma
  soluÃ§Ã£o se k >= n

  â†’ A funÃ§Ã£o is_a_solution() simplesmente checa se k == n

  â†’  Para  cada posiÃ§Ã£o k, os candidatos sÃ£o sempre 2: verdadeiro
  ou falso, de modo que a funÃ§Ã£o construct_candidates() tambÃ©m  Ã©
  deveras simples

  â†’ A funÃ§Ã£o process_solution() imprime a soluÃ§Ã£o encontrada

  â†’ O algoritmo deve comeÃ§ar no caso base, com k = 0, e input = n

    Â· CÃ³digo: subsets.c

  â†’  A  ordem  dos  subconjuntos gerados depende da etapa da conâ€
  struÃ§Ãµes dos possÃ­veis candidatos


































