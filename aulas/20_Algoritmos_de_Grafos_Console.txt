
                      [1mAlgoritmos de Grafos[0m


[4mCaminhos[24m [4mmais[24m [4mcurtos[0m

  ‚Üí  O problema de se determinar o caminho mais curto em um grafo
  n√£o ponderado j√° foi discutido anteriormente, e √© resolvido com
  uma travessia por extens√£o

  ‚Üí Contudo, o BFS n√£o resolve o problema para grafos ponderados

  ‚Üí  Ser√£o  apresentados  dois  algoritmos  para  este problema a
  seguir

[4mAlgoritmo[24m [4mde[24m [4mDijkstra[0m

  ‚Üí Este algoritmo determina, para um dado v√©rtice v,  o  caminho
  mais  curto de v at√© qualquer outro v√©rtice do grafo, incluse o
  v√©rtice destino d

  ‚Üí A ideia b√°sica do algoritmo  √©  semelhante  ao  algoritmo  de
  Prim:  a  cada  itera√ß√£o,  ser√°  adicionado  um √∫nico v√©rtice √†
  √°rvore de v√©rtices na qual sabemos o caminho mais curto para v

  ‚Üí Ser√° mantido o registro do melhor caminho at√© o momento  para
  todos  os v√©rtices fora da √°rvore, e ent√£o estes v√©rtices ser√£o
  inseridos em ordem crescente de custo

  ‚Üí Embora o algoritmo de Prim (√°rvore  m√≠nima  de  espalhamento)
  leve  em  considera√ß√£o apenas o grau da aresta, no algoritmo de
  Dijkstra  (caminho  m√≠nimo)  √©  fun√ß√£o  do  nova  aresta  e  da
  dist√¢ncia at√© o in√≠cio da √°rvore de v√©rtices

  ‚Üí Isto dito, a implementa√ß√£o √© bastante semelhante nos dois ca‚Äê
  sos

    ¬∑ C√≥digo: dijkstra.c

  ‚Üí Este algoritmo, contudo, funciona apenas para grafos que  n√£o
  cont√©m  custos  negativos  (embora seja dif√≠cil encontr√°‚Äêlos na
  pr√°tica)

  ‚Üí O algoritmo de Floyd funciona em tais casos, a menos que  ex‚Äê
  istam  ciclos  de  custo negativo, o que distorce o problema do
  caminho min√≠mo (ficar girando em tal ciclo diminuiria  o  custo
  indefinidamente)

[4mCaminho[24m [4mM√≠nimo[24m [4mem[24m [4mtodos[24m [4mos[24m [4mpares[0m

  ‚Üí  Situa√ß√µes  pr√°ticas  podem  exigir o conhecimento do caminho
  mais curto entre todos os pares de um grafo (como o melhor  lo‚Äê
  cal para a instala√ß√£o de um com√©rcio, determinar o "centro" e o
  "di√¢metro" de um grafo, etc)

  ‚Üí Embora tal problema possa ser solucionado aplicando  o  algo‚Äê
  ritmo  de  Dijkstra em cada um dos n v√©rtices do grafo, o algo‚Äê
  ritmo de Floyd √© o mais apropriado para tal situa√ß√£o

  ‚Üí Tal algoritmo se adapta melhor para  a  representa√ß√£o  de  um
  grafo como uma matriz de adjac√™ncias, onde ser√£o armazenadas as
  arestas/pesos entre os n√≥s do grafo

  ‚Üí Para representar as arestas n√£o presentes, em geral  se  uti‚Äê
  liza  o n√∫mero zero para grafos n√£o ponderados (sendo o valor 1
  o indicativo da presen√ßa da aresta)

  ‚Üí Tal representa√ß√£o n√£o √© adequada para grafos ponderados,  uma
  vez  que  o valor zero significaria uma travessia "livre" entre
  os dois n√≥s. Uma alternativa √© utilizar o maior  valor  inteiro
  (MAXINT) como sentinela

    ¬∑ C√≥digo: floyd.c, fun√ß√µes initialize() e read()

  ‚Üí  O algoritmo tem in√≠cio numerando os v√©rtices do grafo de 1 a
  n, utilizando estes n√∫meros como crit√©rio de ordena√ß√£o,  e  n√£o
  como r√≥tulos

  ‚Üí   Ser√£o ent√£o realizadas n itera√ß√µes, onde a k‚Äê√©sima itera√ß√£o
  permite apenas os k primeiros  v√©rtices  como  passos  interme‚Äê
  di√°rios entre cada par de v√©rtices

  ‚Üí   Na  etapa  k = 0, a matriz resultante √© a pr√≥pria matriz de
  adjac√™ncias

  ‚Üí Em cada etapa adicional, a adi√ß√£o do k‚Äê√©simo v√©rtice pode at‚Äê
  ualizar  o  caminho  m√≠nimo,  atrav√©s  da  express√£o W[i,j]^k =
  min(W[W[i,j]^k, W[i,k]^(k‚Äê1) + W[k,j]^(k‚Äê1))

    ¬∑ C√≥digo: floyd.c

  ‚Üí Observe que o algoritmo n√£o preserva o caminho m√≠nimo, apenas
  seu custo

  ‚Üí  Outra  aplica√ß√£o  do  algoritmo  de  Floyd  √©  o  c√°lculo do
  fechamento transitivo de um grafo direcionado, isto √©, determi‚Äê
  nar se um v√©rtice √© ou n√£o alcan√ß√°vel a partir de um determina‚Äê
  do n√≥

  ‚Üí Qualquer n√≥ que tenha peso diferente de MAXINT  ao  final  do
  algoritmo √© ating√≠vel

[4mFluxos[24m [4mde[24m [4mRede[24m [4me[24m [4mPareamento[24m [4mBipartido[0m

  ‚Üí  Qualquer  grafo ponderado pode ser visualizado como uma rede
  de canos, onde o peso da aresta (i,j) determina a capacidade do
  cano que liga os n√≥s i e  j

  ‚Üí  Para  um grafo ponderado G e dois v√©rtices s e t, o problema
  do fluxo de rede consiste em determinar o fluxo m√°ximo que pode
  ser  enviado de s para t, respeitando as capacidades m√°ximas de
  cada cano

  ‚Üí Um problema relacionado √© o do pareamento bipartido

  ‚Üí Um pareamento em um grafo G = (V,E) √© um subconjunto E‚Äô de  E
  tal que duas arestas em E‚Äô n√£o compartilham um mesmo v√©rtice

  ‚Üí  Um  pareamento  associa  pares  de v√©rtices de modo que cada
  v√©rtice perten√ßa a apenas um par

  ‚Üí Um grafo √© bipartido ou "bicolor√≠vel" se  os  v√©rtices  podem
  ser divididos em dois grupos L e R de modo que todas as arestas
  de G tem um v√©rtice em L e um v√©rtice em R

  ‚Üí Exemplos de grafos que s√£o bipartidos  na  pr√°tica:  o  grafo
  onde uns v√©rtices representam trabalhos a serem feitos e outros
  as pessoas que podem realiz√°‚Äêlos; ou o grafo onde  os  v√©rtices
  s√£o rapazes e mo√ßas e as arestas s√£o os poss√≠veis relacionamen‚Äê
  tos. Em tais grafos, um pareamento significa  uma  distribui√ß√£o
  de tarefas ou casamentos

  ‚Üí  O maior pareamento bipartido pode ser determinado atrav√©s do
  fluxo de rede

  ‚Üí Basta criar um n√≥ fonte s que √© conectado a cada v√©rtice de L
  por  uma  aresta  de  peso  1, e um n√≥ sif√£o t conectado a cada
  v√©rtice de R por uma aresta de peso 1

  ‚Üí Depois, basta atribuir peso 1 a todas as arestas de G. Agora,
  o fluxo m√°ximo de s a t determinar o maior pareamento em G

  ‚Üí  O  fluxo  pode  ser  obtido  atrav√©s  da escolha das arestas
  pareadas e as suas conex√µes da fonte para o sif√£o

  ‚Üí O algoritmo mais simples de implementar para  o  problema  de
  fluxo de rede √© o de Ford‚ÄêFulkerson

  ‚Üí  Neste algoritmo, cada aresta mant√©m o registro da capacidade
  de fluxo que est√° correndo atualmente sobre ela assim como  sua
  capacidade residual

  ‚Üí Em seguida, se procura qualquer caminho da fonte ao sif√£o que
  aumenta o fluxo total e o utiliza para ampliar o total

  ‚Üí O algoritmo termina quando n√£o existir nenhum caminho que am‚Äê
  plie o total

    ¬∑ C√≥digo: netflow.c

  ‚Üí  Uma travessia bfs pode ser utilizada para determinar os cam‚Äê
  inhos que ampliam o fluxo, sendo permitido apenas  caminhar  em
  arestas que tenham capacidade remanescente

  ‚Üí  A quantidade m√°xima que pode ser transferida √© limitada pela
  menor capacidade residual (assim com o tr√°fego √© limitado  pela
  ponto de maior congestionamento)

  ‚Üí  Enviar  uma  unidade de fluxo adicional de atrav√©s da aresta
  direcionada (i,j) reduz sua capacidade residual mas  aumenta  a
  capacidade residual de (j,i)

  ‚Üí  Deste  modo,  a  busca pela amplia√ß√£o do fluxo deve levar em
  considera√ß√£o ambos os sentidos das arestas

  ‚Üí A inicializa√ß√£o de um grafo de fluxo  requer  a  cria√ß√£o  das
  arestas  direcionadas  (i,j) e (j,i), com fluxos todos iguais a
  zero, e o fluxo residual de (i,j) sendo igual ao seu peso,  en‚Äê
  quanto que o res√≠duo inicial de (j,i) √© igual a zero

  ‚Üí  Redes  de  fluxo s√£o uma t√©cnica de algoritmos avan√ßada, que
  exige experi√™ncia para identificar quando um problema pode  ser
  resolvido por ela ou n√£o















